#' Import a VCF file and extract read count
#' @description
#' Import a VCF file and extract read-count and variant allele frequencies. Currently VCF files generated by `mutect2` and `strelka2` are supported.
#'
#' @param vcf Input indexed VCF file.
#' @param ignore_xy Ignore allosomes. Default TRUE
#' @param t_sample Sample name for tumor. Must be same as in VCF. Strelka hardcodes tumor sample name to "TUMOR"
#' @param vcf_source Tool used for generating VCF file. Can be `strelka` ot `mutect`
#' @param min_vaf Remove variants with vcf below threshold. Default 0.01
#' @param min_depth Minimum required depth for a variant to be considered. Default 30.
#' @examples
#' mutect_vcf = system.file("extdata", "mutect.somatic.vcf.gz", package = "NBevolution")
#' m_data = readVCF(vcf = mutect_vcf, vcf_source = "mutect")
#' strelka_vcf = system.file("extdata", "strelka2.somatic.snvs.vcf.gz", package = "NBevolution")
#' s_data = readVCF(vcf = strelka_vcf, vcf_source = "strelka")
#' @import data.table vcfR
#' @return a data.table with chrom, pos, ref, alt, t_ref_count, t_alt_count, t_depth, t_vaf
#' @export

readVCF = function(vcf = NULL, ignore_XY = TRUE, vcf_source = "strelka", min_vaf = 0.01, min_depth = 30, t_sample = NULL){

  if(is.null(vcf)){
    stop("Missing input VCF file!")
  }

  #Source of VCF
  vcf_sources <- c("strelka", "mutect")
  vcf_source <- match.arg(arg = vcf_source, choices = vcf_sources, several.ok = FALSE)

  #vcf <- "inst/extdata/somatic.snvs.vcf.gz"
  if(is.null(t_sample)){
    t_sample <- .get_t_SM(vcf = vcf)
    message("Assuming ", t_sample, " as tumor")
  }

  message("Importing VCF..")
  v <- vcfR::read.vcfR(file = vcf, verbose = FALSE)
  message("Total variants        : ", nrow(v@gt))
  v <- v[vcfR::is.biallelic(x = v)] #Only keep bialleleic variants
  if(nrow(v) == 0){
    stop("No bi-allelic variants found!")
  }
  message("Bi-allelic variants   : ", nrow(v@gt))
  v <- v[!vcfR::is.indel(v)] #Remove INDELS (only SNVs)
  if(nrow(v) == 0){
    stop("No single nucelotide variants found!")
  }
  message("single nucl. variants : ", nrow(v@gt))

  tum_format <- v@gt[,t_sample]
  dt <- data.table::data.table(chrom = vcfR::getCHROM(v), pos = vcfR::getPOS(v), ref = vcfR::getREF(v), alt = vcfR::getALT(v))
  dp_dt <- .get_depth(FORMAT = tum_format, source = vcf_source)
  dt <- cbind(dt, dp_dt)

  #devtools::check produces notes about global variables. Declare here just in case. Comment it out - no probs
  #t_vaf <- A <- C <- t_ref_count <- t_depth <- t_alt_count <- G <- C <- chrom <- t_vaf <- t_depth <- . <- pos <- ref <- alt <- NULL

  #Strelka doesnt provide VAF or ref/alt count. Instead contains A,T,G,C depth
  #Match with alt allele and estimate VAF
  if(vcf_source == "strelka"){
    dt <- split(dt, dt$alt)

    dt <- lapply(seq_along(dt), function(alt_idx){
      alt_base = names(dt)[alt_idx]
      d <- dt[[alt_idx]]

      if(alt_base == "A"){
        d[, t_vaf := A/t_depth]
        d[, t_ref_count := t_depth - A]
        d[, t_alt_count := A]
      }else if(alt_base == "T"){
        d[, t_vaf := T/t_depth]
        d[, t_ref_count := t_depth - T]
        d[, t_alt_count := T]
      }else if(alt_base == "G"){
        d[, t_vaf := G/t_depth]
        d[, t_ref_count := t_depth - G]
        d[, t_alt_count := G]
      }else if(alt_base == "C"){
        d[, t_vaf := C/t_depth]
        d[, t_ref_count := t_depth - C]
        d[, t_alt_count := C]
      }
      d
    })
    dt <- data.table::rbindlist(l = dt, use.names = TRUE, fill = TRUE)
  }

  #Only analyze primary contigs (either with or without the chr prefix)
  primary_contigs <- c(paste0("chr", 1:22), 1:22, c("chrX", "chrY", "X", "Y"))
  dt <- dt[chrom %in% primary_contigs]
  message("Primary contig vars.  : ", nrow(dt))

  #Remove X and Y contigs
  if(ignore_XY){
    dt <- dt[!chrom %in% c("chrX", "chrY", "X", "Y")]
    message("Autosomal variants    : ", nrow(dt))
  }

  #Filter for VAF and depth. Return only necessary columns
  message("Filtering for min_depth and VAF..")
  dt = dt[t_vaf >= min_vaf][t_depth >= min_depth][,.(chrom, pos, ref, alt, t_ref_count, t_alt_count, t_depth, t_vaf)]
  setattr(x = dt, name = 't_sample', value = t_sample) #Add sample name as an attribute
  dt
}

#Parse depth information from FORMAT field
.get_depth = function(FORMAT, source = "strelka"){

  if(source == "strelka"){
    #Example strelka FORMAT field
    #"82:0:0:0:0,0:1,1:2,2:79,79"
    #"DP:FDP:SDP:SUBDP:AU:CU:GU:TU"
    dp <- data.table::tstrsplit(x = FORMAT, split = ":", keep = 5:8, names = c("A", "C", "G", "T"))
    dp <- lapply(dp, function(d){
      as.numeric(unlist(data.table::tstrsplit(x = d, split = ",", keep = 1)))
    })
    dp <- as.data.frame(dp)
    dp$t_depth <- rowSums(x = dp)
  }else{
    #Example mutect FORMAT field.
    #"0/1:70,4:0.058:74:21,1:37,2:68,4:17,53,4,0"
    #"GT:AD:AF:DP:F1R2:F2R1:FAD:SB"
    dp <- data.table::tstrsplit(FORMAT, split = ":", keep = 2)
    dp = lapply(data.table::tstrsplit(x = dp[[1]], split = ','), as.numeric)
    names(dp) = c("t_ref_count", "t_alt_count")
    dp <- as.data.frame(dp)
    dp$t_depth = rowSums(dp)
    dp$t_vaf = dp$t_alt_count / dp$t_depth
  }

  data.table::setDT(x = dp)
  dp
}

#retrieve tumor sample ID
.get_t_SM = function(vcf){
  temp <- data.table::fread(file = vcf, skip = "#CHROM", nrows = 1)
  stdcols = c("#CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO", "FORMAT")
  sm_ids = setdiff(colnames(temp), stdcols)
  #In case matched normal is used, second entry will always be the tumor sample, if not first sample is assumed to be tumor
  ifelse(length(sm_ids) > 1, yes = sm_ids[2], no = sm_ids[1])
}
