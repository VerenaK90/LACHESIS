#' Import a VCF file and extract read count
#' @description
#' Import a VCF file and extract read-count and variant allele frequencies. Currently VCF files generated by `mutect2` and `strelka2` are supported.
#'
#' @param vcf Input indexed VCF file.
#' @param ignore.XY Ignore allosomes. Default TRUE
#' @param t.sample Sample name for tumor. Must be same as in VCF. Strelka hardcodes tumor sample name to "TUMOR"
#' @param ignore.XY Tool used for generating VCF file. Can be `strelka` ot `mutect`
#' @param min.vaf Remove variants with vcf below threshold. Default 0.01
#' @param min.depth Minimum required depth for a variant to be considered. Default 30.
#' @examples
#' mutect_vcf = system.file("extdata", "mutect.somatic.vcf.gz", package = "NBevolution")
#' m_data = readVCF(vcf = mutect_vcf, vcf.source = "mutect")
#' strelka_vcf = system.file("extdata", "strelka2.somatic.snvs.vcf.gz", package = "NBevolution")
#' s_data = readVCF(vcf = strelka_vcf, vcf.source = "strelka")
#' @import data.table vcfR
#' @return a data.table with chrom, pos, ref, alt, t_ref_count, t_alt_count, t_depth, t_vaf
#' @export

readVCF = function(vcf = NULL, ignore.XY = TRUE, vcf.source = "strelka", min.vaf = 0.01, min.depth = 30, t.sample = NULL){

  if(is.null(vcf)){
    stop("Missing input VCF file!")
  }

  vcf.sources <- c("strelka", "mutect")
  vcf.source <- match.arg(arg = vcf.source, choices = vcf.sources, several.ok = FALSE)

  if(is.null(t.sample)){
    t.sample <- .get_t_SM(vcf = vcf)
    message("Assuming ", t.sample, " as tumor")
  }

  message("Importing VCF..")
  v <- vcfR::read.vcfR(file = vcf, verbose = FALSE)
  message("Total variants        : ", nrow(v@gt))
  v <- v[vcfR::is.biallelic(x = v)] #Only keep bialleleic variants
  if(nrow(v) == 0){
    stop("No bi-allelic variants found!")
  }
  message("Bi-allelic variants   : ", nrow(v@gt))
  v <- v[!vcfR::is.indel(v)] #Remove INDELS (only SNVs)
  if(nrow(v) == 0){
    stop("No single nucelotide variants found!")
  }
  message("single nucl. variants : ", nrow(v@gt))

  #convert tumor FORMAT to a data.frame
  tum_format <- v@gt[,t.sample]
  format_df <- as.data.frame(data.table::tstrsplit(tum_format, split = ":"))
  colnames(format_df) <- unlist(data.table::tstrsplit(x = v@gt[1,"FORMAT"], split = ":"))

  #Make a df of all necessary columns
  dt <- data.table::data.table(chrom = vcfR::getCHROM(v), pos = vcfR::getPOS(v), ref = vcfR::getREF(v), alt = vcfR::getALT(v))
  dt <- cbind(dt, format_df)

  #remove chr prefix
  if(grepl(pattern = "^chr", x = dt$chrom[1])){
    dt$chrom <- gsub(pattern = "^chr", replacement = "", x = dt$chrom)
  }

  #Only analyze primary contigs (either with or without the chr prefix)
  primary_contigs <- c(1:22, c("X", "Y"))
  dt <- dt[chrom %in% primary_contigs]
  message("Primary contig vars.  : ", nrow(dt))

  #Remove X and Y contigs
  if(ignore.XY){
    dt <- dt[!chrom %in% c("chrX", "chrY", "X", "Y")]
    message("Autosomal variants    : ", nrow(dt))
  }

  #Parse FORMAT field and get vaf, etc
  dt <- .get_depth_dt(d = dt, source = vcf.source)

  #Filter for VAF and depth. Return only necessary columns
  message("Filtering for min.depth and VAF..")
  dt = dt[t_vaf >= min.vaf][t_depth >= min.depth][,.(chrom, pos, ref, alt, t_ref_count, t_alt_count, t_depth, t_vaf)]
  data.table::setattr(x = dt, name = 't.sample', value = t.sample) #Add sample name as an attribute
  dt
}

.get_depth_dt <- function(d, source = "strelka"){

  if(source == "strelka"){
    d_dp <- apply(X = d[,.(AU, CU, GU, TU)], 2, function(x){
      as.numeric(unlist(data.table::tstrsplit(x = x, split = ",", keep = 1)))
    })
    colnames(d_dp) = gsub(pattern = "U$", replacement = "", x = colnames(d_dp))
    d_dp = as.data.frame(d_dp)
    d_dp$t_depth = rowSums(d_dp)
    d = cbind(d, d_dp)

    #Strelka doesnt provide VAF or ref/alt count. Instead contains A,T,G,C depth
    #Match with alt allele and estimate VAF
    d <- split(d, d$alt)

    d <- lapply(seq_along(d), function(alt_idx){
      alt_base = names(d)[alt_idx]
      dalt <- d[[alt_idx]]

      if(alt_base == "A"){
        dalt[, t_vaf := A/t_depth]
        dalt[, t_ref_count := t_depth - A]
        dalt[, t_alt_count := A]
      }else if(alt_base == "T"){
        dalt[, t_vaf := T/t_depth]
        dalt[, t_ref_count := t_depth - T]
        dalt[, t_alt_count := T]
      }else if(alt_base == "G"){
        dalt[, t_vaf := G/t_depth]
        dalt[, t_ref_count := t_depth - G]
        dalt[, t_alt_count := G]
      }else if(alt_base == "C"){
        dalt[, t_vaf := C/t_depth]
        dalt[, t_ref_count := t_depth - C]
        dalt[, t_alt_count := C]
      }
      dalt
    })
    d <- data.table::rbindlist(l = d, use.names = TRUE, fill = TRUE)
  }else if(source == "mutect"){
    d_ad <- as.data.frame(data.table::tstrsplit(d$AD, split = ","))
    colnames(d_ad) <- c("t_ref_count", "t_alt_count")
    d_ad = as.data.frame(apply(d_ad, 2, as.numeric))
    d_ad$t_depth <- rowSums(d_ad)
    d_ad$t_vaf <- d_ad$t_alt_count / d_ad$t_depth
    d <-cbind(d, d_ad)
  }else{
    stop("Unknown format!")
  }

  d[,.(chrom, pos, ref, alt, t_depth, t_ref_count, t_alt_count, t_vaf)]
}

#Parse depth information from FORMAT field (DEPRECATED)
.get_depth <- function(FORMAT, source = "strelka"){

  if(source == "strelka"){
    #Example strelka FORMAT field
    #"82:0:0:0:0,0:1,1:2,2:79,79"
    #"DP:FDP:SDP:SUBDP:AU:CU:GU:TU"
    dp <- data.table::tstrsplit(x = FORMAT, split = ":", keep = 5:8, names = c("A", "C", "G", "T"))
    dp <- lapply(dp, function(d){
      as.numeric(unlist(data.table::tstrsplit(x = d, split = ",", keep = 1)))
    })
    dp <- as.data.frame(dp)
    dp$t_depth <- rowSums(x = dp)
  }else{
    #Example mutect FORMAT field.
    #"0/1:70,4:0.058:74:21,1:37,2:68,4:17,53,4,0"
    #"GT:AD:AF:DP:F1R2:F2R1:FAD:SB"
    dp <- data.table::tstrsplit(FORMAT, split = ":", keep = 2)
    dp = lapply(data.table::tstrsplit(x = dp[[1]], split = ','), as.numeric)
    names(dp) = c("t_ref_count", "t_alt_count")
    dp <- as.data.frame(dp)
    dp$t_depth <- rowSums(dp)
    dp$t_vaf <- dp$t_alt_count / dp$t_depth
  }

  data.table::setDT(x = dp)
  dp[order(chr, pos)]
}

#retrieve tumor sample ID
.get_t_SM = function(vcf){
  temp <- data.table::fread(file = vcf, skip = "#CHROM", nrows = 1)
  stdcols = c("#CHROM", "POS", "ID", "REF", "ALT", "QUAL", "FILTER", "INFO", "FORMAT")
  sm_ids = setdiff(colnames(temp), stdcols)
  #In case matched normal is used, second entry will always be the tumor sample, if not first sample is assumed to be tumor
  ifelse(length(sm_ids) > 1, yes = sm_ids[2], no = sm_ids[1])
}
